// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as Char from "bs-platform/lib/es6/char.js";
import * as List from "bs-platform/lib/es6/list.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Stream from "bs-platform/lib/es6/stream.js";
import * as $$String from "bs-platform/lib/es6/string.js";
import * as Hashtbl from "bs-platform/lib/es6/hashtbl.js";
import * as Pervasives from "bs-platform/lib/es6/pervasives.js";
import * as Caml_format from "bs-platform/lib/es6/caml_format.js";
import * as Caml_js_exceptions from "bs-platform/lib/es6/caml_js_exceptions.js";

function is_word(t) {
  if (typeof t === "number") {
    if (t >= 14) {
      return t < 17;
    } else {
      return t < 9;
    }
  } else {
    return true;
  }
}

function to_string(t) {
  if (typeof t !== "number") {
    if (t.TAG) {
      return t._0;
    } else {
      return String(t._0);
    }
  }
  switch (t) {
    case /* Phylogeny */0 :
        return "phylogeny";
    case /* Name */1 :
        return "name";
    case /* Description */2 :
        return "description";
    case /* Clade */3 :
        return "clade";
    case /* Rank */4 :
        return "rank";
    case /* Confidence */5 :
        return "confidence";
    case /* Taxonomy */6 :
        return "taxonomy";
    case /* SciName */7 :
        return "scientific_name";
    case /* ID */8 :
        return "id";
    case /* LAngle */9 :
        return "<";
    case /* LAngleSlash */10 :
        return "</";
    case /* RAngle */11 :
        return ">";
    case /* Quote */12 :
        return "quote";
    case /* Eq */13 :
        return "=";
    case /* Dot */14 :
        return ".";
    case /* True */15 :
        return "true";
    case /* False */16 :
        return "false";
    case /* EOF */17 :
        return "EOF";
    case /* Unit */18 :
        return "Unit";
    
  }
}

var word_token_map = Hashtbl.create(undefined, 16);

Hashtbl.add(word_token_map, "phylogeny", /* Phylogeny */0);

Hashtbl.add(word_token_map, "name", /* Name */1);

Hashtbl.add(word_token_map, "description", /* Description */2);

Hashtbl.add(word_token_map, "clade", /* Clade */3);

Hashtbl.add(word_token_map, "rank", /* Rank */4);

Hashtbl.add(word_token_map, "confidence", /* Confidence */5);

Hashtbl.add(word_token_map, "taxonomy", /* Taxonomy */6);

Hashtbl.add(word_token_map, "scientific_name", /* SciName */7);

Hashtbl.add(word_token_map, "id", /* ID */8);

Hashtbl.add(word_token_map, "true", /* True */15);

Hashtbl.add(word_token_map, "false", /* False */16);

function get_next_line(s, _acc) {
  while(true) {
    var acc = _acc;
    var c = Stream.peek(s);
    if (c !== undefined) {
      Stream.junk(s);
      if (c === 10) {
        return acc;
      }
      if (c === 13) {
        return acc;
      }
      _acc = acc + Char.escaped(c);
      continue ;
    }
    if (acc === "") {
      throw {
            RE_EXN_ID: "End_of_file",
            Error: new Error()
          };
    }
    return acc;
  };
}

function make_stream_helper(s, is_file) {
  var stream;
  if (is_file) {
    var in_channel = Pervasives.open_in(s);
    stream = Stream.from(function (param) {
          try {
            return Pervasives.input_line(in_channel);
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.RE_EXN_ID === "End_of_file") {
              return ;
            }
            throw exn;
          }
        });
  } else {
    var char_stream = Stream.of_string(s);
    stream = Stream.from(function (param) {
          try {
            return get_next_line(char_stream, "");
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.RE_EXN_ID === "End_of_file") {
              return ;
            }
            throw exn;
          }
        });
  }
  var s$1 = Stream.peek(stream);
  if (s$1 === undefined) {
    return stream;
  }
  var val;
  try {
    val = $$String.sub(s$1, 0, 5);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Invalid_argument") {
      return stream;
    }
    throw exn;
  }
  if (val !== "<?xml") {
    return stream;
  }
  Stream.junk(stream);
  return stream;
}

function stream_of_file(f) {
  return make_stream_helper(f, true);
}

function stream_of_string(s) {
  return make_stream_helper(s, false);
}

function stream_of_line(stream) {
  var str;
  try {
    str = Stream.next(stream);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Stream.Failure) {
      throw {
            RE_EXN_ID: "End_of_file",
            Error: new Error()
          };
    }
    throw exn;
  }
  return Stream.of_string(str);
}

function is_special_char(c) {
  if (c >= 60) {
    return c < 63;
  } else {
    return c === 34;
  }
}

function lex_keyword(stream, acc) {
  var c = Stream.peek(stream);
  if (c !== undefined) {
    var val;
    try {
      val = c;
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Stream.Failure) {
        return lex_keyword_helper(acc);
      }
      throw exn;
    }
    if (val !== 32) {
      if (Hashtbl.mem(word_token_map, acc)) {
        return Hashtbl.find(word_token_map, acc);
      } else if (is_special_char(c)) {
        return {
                TAG: /* Word */1,
                _0: acc
              };
      } else {
        Stream.junk(stream);
        return lex_keyword(stream, acc + Char.escaped(c));
      }
    } else {
      return lex_keyword_helper(acc);
    }
  } else {
    return lex_keyword_helper(acc);
  }
}

function lex_keyword_helper(acc) {
  if (Hashtbl.mem(word_token_map, acc)) {
    return Hashtbl.find(word_token_map, acc);
  } else {
    return {
            TAG: /* Word */1,
            _0: acc
          };
  }
}

function is_number(c) {
  return !(c > 57 || c < 48);
}

function lex_number(stream, _acc) {
  while(true) {
    var acc = _acc;
    var c = Stream.peek(stream);
    if (c === undefined) {
      return {
              TAG: /* Num */0,
              _0: Caml_format.caml_int_of_string(acc)
            };
    }
    if (!is_number(c)) {
      return {
              TAG: /* Num */0,
              _0: Caml_format.caml_int_of_string(acc)
            };
    }
    Stream.junk(stream);
    _acc = acc + Char.escaped(c);
    continue ;
  };
}

function tokenize_next_line(stream) {
  var x;
  try {
    x = stream_of_line(stream);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "End_of_file") {
      return {
              hd: /* EOF */17,
              tl: /* [] */0
            };
    }
    throw exn;
  }
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var exit = 0;
    var c;
    try {
      c = Stream.next(x);
      exit = 1;
    }
    catch (raw_exn$1){
      var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
      if (exn$1.RE_EXN_ID === Stream.Failure) {
        return List.rev(acc);
      }
      if (exn$1.RE_EXN_ID === "End_of_file") {
        return {
                hd: /* EOF */17,
                tl: /* [] */0
              };
      }
      throw exn$1;
    }
    if (exit === 1) {
      var exit$1 = 0;
      if (c >= 32) {
        if (c !== 46) {
          if (c >= 60) {
            if (c >= 63) {
              exit$1 = 2;
            } else {
              switch (c - 60 | 0) {
                case 0 :
                    var n = Stream.peek(x);
                    if (n === undefined) {
                      return List.rev({
                                  hd: /* LAngle */9,
                                  tl: acc
                                });
                    }
                    if (n === /* "/" */47) {
                      Stream.junk(x);
                      _acc = {
                        hd: /* LAngleSlash */10,
                        tl: acc
                      };
                      continue ;
                    }
                    _acc = {
                      hd: /* LAngle */9,
                      tl: acc
                    };
                    continue ;
                case 1 :
                    _acc = {
                      hd: /* Eq */13,
                      tl: acc
                    };
                    continue ;
                case 2 :
                    _acc = {
                      hd: /* RAngle */11,
                      tl: acc
                    };
                    continue ;
                
              }
            }
          } else if (c >= 35) {
            exit$1 = 2;
          } else {
            switch (c - 32 | 0) {
              case 0 :
                  continue ;
              case 1 :
                  exit$1 = 2;
                  break;
              case 2 :
                  _acc = {
                    hd: /* Quote */12,
                    tl: acc
                  };
                  continue ;
              
            }
          }
        } else {
          _acc = {
            hd: /* Dot */14,
            tl: acc
          };
          continue ;
        }
      } else if (c >= 11) {
        if (c !== 13) {
          exit$1 = 2;
        } else {
          continue ;
        }
      } else {
        if (c >= 9) {
          continue ;
        }
        exit$1 = 2;
      }
      if (exit$1 === 2) {
        if (is_number(c)) {
          _acc = {
            hd: lex_number(x, Char.escaped(c)),
            tl: acc
          };
          continue ;
        }
        _acc = {
          hd: lex_keyword(x, Char.escaped(c)),
          tl: acc
        };
        continue ;
      }
      
    }
    
  };
}

function token_function_builder(stream) {
  var tokens_in_line = {
    contents: tokenize_next_line(stream)
  };
  var token_function = {
    contents: (function (b, param) {
        return /* EOF */17;
      })
  };
  token_function.contents = (function (b) {
      if (b) {
        return function (param) {
          var match = tokens_in_line.contents;
          if (match) {
            return match.hd;
          } else {
            tokens_in_line.contents = tokenize_next_line(stream);
            return Curry._2(token_function.contents, true, undefined);
          }
        };
      } else {
        return function (param) {
          var match = tokens_in_line.contents;
          if (match) {
            tokens_in_line.contents = match.tl;
            return /* Unit */18;
          } else {
            tokens_in_line.contents = tokenize_next_line(stream);
            return /* Unit */18;
          }
        };
      }
    });
  return token_function.contents;
}

export {
  is_word ,
  to_string ,
  stream_of_file ,
  stream_of_string ,
  tokenize_next_line ,
  token_function_builder ,
  
}
/* word_token_map Not a pure module */
