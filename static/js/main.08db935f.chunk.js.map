{"version":3,"sources":["components/Context.js","components/HomeContent.js","ocaml_src/dna.bs.js","components/GeneratePhyloContent.js","ocaml_src/tree.bs.js","ocaml_src/lexer.bs.js","ocaml_src/phylo_parser.bs.js","components/VisualizePhyloContent.js","App.js","serviceWorker.js","index.js"],"names":["Context","React","createContext","Content","Layout","HomeContents","useContext","goVisualizePhylo","goGeneratePhylo","class","justify","className","gutter","lg","md","sm","onClick","Caml_exceptions","parse_line","str","dna_seq","str$1","$$String","c","switcher","is_dna","$$Buffer","from_string","to_string","reader","FileReader","parseDNA","file","a","onload","console","log","Dna","result","readAsText","e","fastaUploadProps","accept","multiple","transformFile","GeneratePhyloContent","UploadOutlined","clade_ids","tree","tag","List","rep_ok","t","all_clade_ids","Caml_obj","Caml_primitive","clade_ids_uniq","Pervasives","counter","contents","empty_000","empty","Block","undefined","is_empty","info","leaf","sci_name","id","name","print_output","print_char","Char","print_string","s","print_spaces","n","x","print_vert_helper","_ds","_pos","end_str","pos","ds","h","print_verts","print_branch","print_tree_helper","_t_lst","d","t_lst","new_ds","is_word","String","word_token_map","Hashtbl","lex_keyword","stream","acc","Stream","val","exn","lex_keyword_helper","is_special_char","is_number","lex_number","_acc","Caml_format","tokenize_next_line","Caml_builtin_exceptions","stream_of_line","exit","exn$1","exit$1","$$SyntaxError","empty_phylo","description","Tree$PhyloLibWeb","empty_clade_attr","rank","confidence","taxonomy","peek","param","consume_token","consume","token","Curry","Lexer$PhyloLibWeb","parse_words","w","add_assoc","lst","attr","consume_end_tag","add_attr","return_tag","match","tag_name","str_attr","num_attr","bool_attr","words","x$1","parse_start_tag","is_valid_tag","_tag","ignore_tag","parse_name","parse_description","descr","parse_float","f","parse_confidence","n$1","parse_id","parse_scientific_name","parse_taxonomy","_taxonomy","scientific_name","parse_clade","trees","taxon","taxon$1","clade","from_phylo","tokenizer","tokens_in_line","token_function","b","raw_exn","Caml_js_exceptions","match$1","phylo","parse_phylogeny","printFile","PhyloParser","Tree","uploadProps","action","headers","authorization","VisualizePhyloContent","Header","useBack","goHome","content","ArrowLeftOutlined","style","alignSelf","paddingRight","title","trigger","InfoCircleOutlined","App","useState","screen","setScreen","context","useMemo","CurrScreen","Provider","value","Boolean","window","location","hostname","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.08db935f.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nconst Context = React.createContext();\r\n\r\nexport default Context;\r\n","import React from 'react';\r\nimport { Row, Col, Layout } from 'antd';\r\nimport '../App.css';\r\nimport Context from './Context';\r\nconst { Content } = Layout;\r\n\r\nexport default function HomeContents() {\r\n  const i = 'Welcome to PhyloCaml';\r\n  const { goVisualizePhylo, goGeneratePhylo } = React.useContext(Context);\r\n  return (\r\n    <div class=\"wrapper main\">\r\n      <Content justify=\"center\">\r\n        <Row className=\"intro\" justify=\"center\" gutter={[16, 16]}>\r\n          <div>\r\n            <h1>{i}</h1>\r\n            <h2>A phylogenetic library written in OCaml.</h2>\r\n            <h2>\r\n              Inferring Evolutionary History through modern genetic similarity.\r\n          </h2>\r\n          </div>\r\n        </Row>\r\n        <Row justify=\"center\" gutter={[16, 40]}>\r\n          <Col lg={7} md={10} sm={12}>\r\n            <div className=\"wrap\">\r\n              <button className=\"offset\" onClick={goGeneratePhylo}>\r\n                Work with .FASTA files\r\n            </button>\r\n            </div>\r\n          </Col>\r\n          <Col lg={7} md={10} sm={12}>\r\n            <div className=\"wrap\">\r\n              <button className=\"offset\" onClick={goVisualizePhylo}>\r\n                Work with PhyloXML files\r\n            </button>\r\n            </div>\r\n          </Col>\r\n        </Row>\r\n      </Content>\r\n    </div>\r\n  );\r\n}\r\n","// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE\r\n\r\nimport * as $$Buffer from \"bs-platform/lib/es6/buffer.js\";\r\nimport * as Stream from \"bs-platform/lib/es6/stream.js\";\r\nimport * as $$String from \"bs-platform/lib/es6/string.js\";\r\nimport * as Pervasives from \"bs-platform/lib/es6/pervasives.js\";\r\nimport * as Caml_exceptions from \"bs-platform/lib/es6/caml_exceptions.js\";\r\nimport * as Caml_builtin_exceptions from \"bs-platform/lib/es6/caml_builtin_exceptions.js\";\r\n\r\nvar Empty = Caml_exceptions.create(\"Dna-PhyloLibWeb.Empty\");\r\n\r\nfunction is_name_line(str) {\r\n  return $$String.sub(str, 0, 1) === \">\";\r\n}\r\n\r\nfunction is_dna(c) {\r\n  var switcher = c - 84 | 0;\r\n  if (!(switcher > 11 || switcher < 0)) {\r\n    return switcher > 10 || switcher < 1;\r\n  }\r\n  switch (switcher) {\r\n    case -18 :\r\n    case -16 :\r\n    case -15 :\r\n    case -14 :\r\n        return false;\r\n    case -19 :\r\n    case -17 :\r\n    case -13 :\r\n        return true;\r\n    default:\r\n      return false;\r\n  }\r\n}\r\n\r\nfunction parse_line(str, dna_seq) {\r\n  var str$1 = $$String.uppercase_ascii(str);\r\n  return $$String.iter((function (c) {\r\n                if (is_dna(c)) {\r\n                  return $$Buffer.add_char(dna_seq, c);\r\n                }\r\n                \r\n              }), str$1);\r\n}\r\n\r\nfunction parse_first_line(dna_stream) {\r\n  var v = Stream.peek(dna_stream);\r\n  if (v !== undefined) {\r\n    if (is_name_line(v)) {\r\n      return Stream.junk(dna_stream);\r\n    } else {\r\n      return ;\r\n    }\r\n  }\r\n  throw Empty;\r\n}\r\n\r\nfunction from_fasta(init_sizeOpt, loc) {\r\n  var init_size = init_sizeOpt !== undefined ? init_sizeOpt : 16384;\r\n  var f = Pervasives.open_in(loc);\r\n  var read_line = function (i) {\r\n    try {\r\n      return Pervasives.input_line(f);\r\n    }\r\n    catch (exn){\r\n      if (exn === Caml_builtin_exceptions.end_of_file) {\r\n        return ;\r\n      }\r\n      throw exn;\r\n    }\r\n  };\r\n  var dna_stream = Stream.from(read_line);\r\n  parse_first_line(dna_stream);\r\n  var dna_seq = $$Buffer.create(init_size);\r\n  Stream.iter((function (str) {\r\n          return parse_line(str, dna_seq);\r\n        }), dna_stream);\r\n  return dna_seq;\r\n}\r\n\r\nfunction from_string(str) {\r\n  var dna_seq = $$Buffer.create(128);\r\n  parse_line(str, dna_seq);\r\n  return dna_seq;\r\n}\r\n\r\nfunction is_empty(dna_seq) {\r\n  return $$Buffer.length(dna_seq) === 0;\r\n}\r\n\r\nvar length = $$Buffer.length;\r\n\r\nfunction get(dna_seq, pos) {\r\n  try {\r\n    return $$Buffer.nth(dna_seq, pos);\r\n  }\r\n  catch (exn){\r\n    return ;\r\n  }\r\n}\r\n\r\nvar get_e = $$Buffer.nth;\r\n\r\nfunction string_of_range(dna_seq, start_pos, end_pos) {\r\n  var range = end_pos - start_pos | 0;\r\n  return $$Buffer.sub(dna_seq, start_pos, range);\r\n}\r\n\r\nvar to_string = $$Buffer.contents;\r\n\r\nexport {\r\n  Empty ,\r\n  from_fasta ,\r\n  from_string ,\r\n  is_empty ,\r\n  length ,\r\n  get ,\r\n  get_e ,\r\n  string_of_range ,\r\n  to_string ,\r\n  \r\n}\r\n/* No side effect */\r\n","import React from 'react';\r\nimport { Button, Row, Layout, Upload } from 'antd';\r\nimport { UploadOutlined } from '@ant-design/icons';\r\nimport * as Dna from '../ocaml_src/dna.bs';\r\n\r\nimport '../App.css';\r\nconst { Content } = Layout;\r\n\r\nconst reader = new FileReader();\r\n\r\nconst parseDNA = async (file) => {\r\n  try {\r\n    reader.onload = () => {\r\n      console.log(Dna.to_string(Dna.from_string(reader.result)));\r\n    };\r\n    reader.readAsText(file);\r\n  } catch (e) {\r\n    console.log(e);\r\n    console.log('File printing failed');\r\n  }\r\n};\r\n\r\nconst fastaUploadProps = {\r\n  accept: '.FASTA, .text, .fasta',\r\n  multiple: true,\r\n  transformFile(file) {\r\n    parseDNA(file);\r\n  },\r\n};\r\n\r\nexport default function GeneratePhyloContent() {\r\n  return (\r\n    <div class=\"wrapper\">\r\n      <Content justify=\"center\">\r\n        <Row className=\"page\" justify=\"center\">\r\n          <div>\r\n            <h1>Generate a Phylogenetic Tree</h1>\r\n            <h2>\r\n              By computing similarity scores for DNA samples of species, we can\r\n              infer their species' evolutionary history through time. Begin by\r\n              uploading .FASTA files that contain DNA sequences, or use our\r\n              example DNA sequences.\r\n            </h2>\r\n          </div>\r\n        </Row>\r\n        <Row className=\"upload\">\r\n          <Upload {...fastaUploadProps}>\r\n            <Button>\r\n              <UploadOutlined /> Upload .FASTA files\r\n            </Button>\r\n          </Upload>\r\n          {/* <Button onClick={() => parseDNA()}> Generate tree </Button> */}\r\n        </Row>\r\n      </Content>\r\n    </div>\r\n  );\r\n}\r\n","// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE\r\n\r\nimport * as Char from \"bs-platform/lib/es6/char.js\";\r\nimport * as List from \"bs-platform/lib/es6/list.js\";\r\nimport * as Block from \"bs-platform/lib/es6/block.js\";\r\nimport * as Caml_obj from \"bs-platform/lib/es6/caml_obj.js\";\r\nimport * as Pervasives from \"bs-platform/lib/es6/pervasives.js\";\r\nimport * as Caml_primitive from \"bs-platform/lib/es6/caml_primitive.js\";\r\nimport * as Caml_exceptions from \"bs-platform/lib/es6/caml_exceptions.js\";\r\n\r\nvar UnknownClade = Caml_exceptions.create(\"Tree-PhyloLibWeb.UnknownClade\");\r\n\r\nfunction clade_ids(tree) {\r\n  if (tree.tag) {\r\n    return /* [] */0;\r\n  } else {\r\n    return /* :: */[\r\n            tree[/* clade_id */0],\r\n            List.flatten(List.map(clade_ids, tree[/* children */1]))\r\n          ];\r\n  }\r\n}\r\n\r\nfunction clade_ids_uniq(t) {\r\n  var all_clade_ids = clade_ids(t);\r\n  return Caml_obj.caml_equal(List.sort_uniq(Caml_primitive.caml_int_compare, all_clade_ids), List.sort(Caml_primitive.caml_int_compare, all_clade_ids));\r\n}\r\n\r\nfunction rep_ok(t) {\r\n  if (clade_ids_uniq(t)) {\r\n    return t;\r\n  } else {\r\n    return Pervasives.failwith(\"clade_ids not unique\");\r\n  }\r\n}\r\n\r\nvar counter = {\r\n  contents: 0\r\n};\r\n\r\nvar empty_000 = /* clade_id */(counter.contents = counter.contents + 1 | 0, counter.contents);\r\n\r\nvar empty = /* Clade */Block.__(0, [\r\n    empty_000,\r\n    /* children : [] */0,\r\n    /* bootstrap */undefined,\r\n    /* rank */undefined,\r\n    /* id */undefined,\r\n    /* name */undefined\r\n  ]);\r\n\r\nfunction is_empty(info) {\r\n  if (info.tag || !(info[/* children */1] === /* [] */0 && info[/* bootstrap */2] === undefined && info[/* rank */3] === undefined && info[/* id */4] === undefined)) {\r\n    return false;\r\n  } else {\r\n    return info[/* name */5] === undefined;\r\n  }\r\n}\r\n\r\nfunction leaf(sci_name, id, name) {\r\n  return /* Leaf */Block.__(1, [\r\n            /* scientific_name */sci_name,\r\n            /* id */id,\r\n            /* name */name\r\n          ]);\r\n}\r\n\r\nfunction leaf_no_params(sci_name) {\r\n  return /* Leaf */Block.__(1, [\r\n            /* scientific_name */sci_name,\r\n            /* id */undefined,\r\n            /* name */undefined\r\n          ]);\r\n}\r\n\r\nfunction size_helper(tree, size) {\r\n  if (tree.tag) {\r\n    return size + 1 | 0;\r\n  }\r\n  var match = tree[/* children */1];\r\n  if (match) {\r\n    return 1 + List.fold_left((function (acc, x) {\r\n                  return acc + size_helper(x, size) | 0;\r\n                }), 0, /* :: */[\r\n                match[0],\r\n                match[1]\r\n              ]) | 0;\r\n  } else {\r\n    return size;\r\n  }\r\n}\r\n\r\nfunction size(tree) {\r\n  return size_helper(tree, 0);\r\n}\r\n\r\nfunction zip(trees, bootstrap, rank, parsed_id, name) {\r\n  if (empty.tag) {\r\n    return Pervasives.failwith(\"Representation invariant broken\");\r\n  } else {\r\n    return rep_ok(/* Clade */Block.__(0, [\r\n                  /* clade_id */(counter.contents = counter.contents + 1 | 0, counter.contents),\r\n                  /* children */trees,\r\n                  /* bootstrap */bootstrap,\r\n                  /* rank */rank,\r\n                  /* id */parsed_id,\r\n                  /* name */name\r\n                ]));\r\n  }\r\n}\r\n\r\nfunction zip_no_params(trees) {\r\n  if (empty.tag) {\r\n    return Pervasives.failwith(\"Representation invariant broken\");\r\n  } else {\r\n    return rep_ok(/* Clade */Block.__(0, [\r\n                  /* clade_id */(counter.contents = counter.contents + 1 | 0, counter.contents),\r\n                  /* children */trees,\r\n                  /* bootstrap */undefined,\r\n                  /* rank */undefined,\r\n                  /* id */undefined,\r\n                  /* name */undefined\r\n                ]));\r\n  }\r\n}\r\n\r\nfunction hierarchy(a, b) {\r\n  if (a.tag) {\r\n    if (b.tag) {\r\n      return Caml_primitive.caml_string_compare(a[/* scientific_name */0], b[/* scientific_name */0]);\r\n    } else {\r\n      return -1;\r\n    }\r\n  } else if (b.tag) {\r\n    return 1;\r\n  } else {\r\n    return Caml_primitive.caml_int_compare(a[/* clade_id */0], b[/* clade_id */0]);\r\n  }\r\n}\r\n\r\nfunction is_equal(a, b) {\r\n  if (a.tag) {\r\n    if (b.tag) {\r\n      return a[/* scientific_name */0] === b[/* scientific_name */0];\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n  if (b.tag) {\r\n    return false;\r\n  }\r\n  var s1 = List.sort(hierarchy, a[/* children */1]);\r\n  var s2 = List.sort(hierarchy, b[/* children */1]);\r\n  var _a = s1;\r\n  var _b = s2;\r\n  var _acc = true;\r\n  while(true) {\r\n    var acc = _acc;\r\n    var b$1 = _b;\r\n    var a$1 = _a;\r\n    if (acc === false) {\r\n      return false;\r\n    }\r\n    if (!a$1) {\r\n      if (b$1) {\r\n        return false;\r\n      } else {\r\n        return true;\r\n      }\r\n    }\r\n    if (!b$1) {\r\n      return false;\r\n    }\r\n    _acc = is_equal(a$1[0], b$1[0]);\r\n    _b = b$1[1];\r\n    _a = a$1[1];\r\n    continue ;\r\n  };\r\n}\r\n\r\nfunction mem(s, t) {\r\n  if (t.tag) {\r\n    return t[/* scientific_name */0] === s;\r\n  } else {\r\n    return List.fold_left((function (acc, tree) {\r\n                  if (acc) {\r\n                    return true;\r\n                  } else {\r\n                    return mem(s, tree);\r\n                  }\r\n                }), false, t[/* children */1]);\r\n  }\r\n}\r\n\r\nvar print_output = {\r\n  contents: \"\"\r\n};\r\n\r\nfunction print_char(c) {\r\n  print_output.contents = print_output.contents + Char.escaped(c);\r\n  \r\n}\r\n\r\nfunction print_string(s) {\r\n  print_output.contents = print_output.contents + s;\r\n  \r\n}\r\n\r\nfunction print_spaces(n) {\r\n  for(var x = 1; x <= n; ++x){\r\n    print_char(/* \" \" */32);\r\n  }\r\n  \r\n}\r\n\r\nfunction print_vert_helper(_ds, _pos, end_str) {\r\n  while(true) {\r\n    var pos = _pos;\r\n    var ds = _ds;\r\n    if (!ds) {\r\n      return ;\r\n    }\r\n    var t = ds[1];\r\n    var h = ds[0];\r\n    if (h === pos && h !== 0) {\r\n      print_spaces(1);\r\n    } else {\r\n      print_spaces(((h - pos | 0) << 1) + (\r\n            h === 0 || pos === 0 ? 0 : 1\r\n          ) | 0);\r\n    }\r\n    if (t === /* [] */0) {\r\n      print_string(end_str);\r\n    } else {\r\n      print_char(/* \"|\" */124);\r\n    }\r\n    _pos = h + 1 | 0;\r\n    _ds = t;\r\n    continue ;\r\n  };\r\n}\r\n\r\nfunction print_verts(ds) {\r\n  print_vert_helper(List.rev(ds), 0, \"|\");\r\n  return print_string(\"\\n\");\r\n}\r\n\r\nfunction print_branch(ds) {\r\n  if (ds) {\r\n    return print_vert_helper(List.rev(ds), 0, \"o-\");\r\n  } else {\r\n    return Pervasives.invalid_arg(\"ds\");\r\n  }\r\n}\r\n\r\nfunction print_tree_helper(_t_lst, d, ds) {\r\n  while(true) {\r\n    var t_lst = _t_lst;\r\n    if (!t_lst) {\r\n      return ;\r\n    }\r\n    var t = t_lst[1];\r\n    var h = t_lst[0];\r\n    if (h.tag) {\r\n      if (ds !== /* [] */0) {\r\n        print_verts(ds);\r\n      } else {\r\n        Pervasives.print_newline(undefined);\r\n      }\r\n      if (ds !== /* [] */0) {\r\n        print_branch(ds);\r\n      }\r\n      print_string(h[/* scientific_name */0] + \"\\n\");\r\n      _t_lst = t;\r\n      continue ;\r\n    }\r\n    var new_ds = t !== /* [] */0 ? /* :: */[\r\n        d,\r\n        ds\r\n      ] : (\r\n        ds ? /* :: */[\r\n            d,\r\n            ds[1]\r\n          ] : /* :: */[\r\n            d,\r\n            /* [] */0\r\n          ]\r\n      );\r\n    if (ds !== /* [] */0) {\r\n      print_verts(ds);\r\n    }\r\n    if (ds !== /* [] */0) {\r\n      print_branch(ds);\r\n    }\r\n    print_string(\"C\\n\");\r\n    print_tree_helper(h[/* children */1], d + 1 | 0, new_ds);\r\n    _t_lst = t;\r\n    continue ;\r\n  };\r\n}\r\n\r\nfunction to_string(t) {\r\n  print_output.contents = \"\";\r\n  print_tree_helper(/* :: */[\r\n        t,\r\n        /* [] */0\r\n      ], 0, /* [] */0);\r\n  return print_output.contents;\r\n}\r\n\r\nexport {\r\n  UnknownClade ,\r\n  empty ,\r\n  is_empty ,\r\n  leaf ,\r\n  leaf_no_params ,\r\n  size ,\r\n  zip ,\r\n  zip_no_params ,\r\n  mem ,\r\n  is_equal ,\r\n  to_string ,\r\n  \r\n}\r\n/* empty Not a pure module */\r\n","// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE\r\n\r\nimport * as Char from \"bs-platform/lib/es6/char.js\";\r\nimport * as List from \"bs-platform/lib/es6/list.js\";\r\nimport * as Block from \"bs-platform/lib/es6/block.js\";\r\nimport * as Curry from \"bs-platform/lib/es6/curry.js\";\r\nimport * as Stream from \"bs-platform/lib/es6/stream.js\";\r\nimport * as $$String from \"bs-platform/lib/es6/string.js\";\r\nimport * as Hashtbl from \"bs-platform/lib/es6/hashtbl.js\";\r\nimport * as Caml_format from \"bs-platform/lib/es6/caml_format.js\";\r\nimport * as Caml_js_exceptions from \"bs-platform/lib/es6/caml_js_exceptions.js\";\r\nimport * as Caml_builtin_exceptions from \"bs-platform/lib/es6/caml_builtin_exceptions.js\";\r\n\r\nfunction is_word(t) {\r\n  if (typeof t === \"number\") {\r\n    if (t >= 14) {\r\n      return t < 17;\r\n    } else {\r\n      return t < 9;\r\n    }\r\n  } else {\r\n    return true;\r\n  }\r\n}\r\n\r\nfunction to_string(t) {\r\n  if (typeof t !== \"number\") {\r\n    if (t.tag) {\r\n      return t[0];\r\n    } else {\r\n      return String(t[0]);\r\n    }\r\n  }\r\n  switch (t) {\r\n    case /* Phylogeny */0 :\r\n        return \"phylogeny\";\r\n    case /* Name */1 :\r\n        return \"name\";\r\n    case /* Description */2 :\r\n        return \"description\";\r\n    case /* Clade */3 :\r\n        return \"clade\";\r\n    case /* Rank */4 :\r\n        return \"rank\";\r\n    case /* Confidence */5 :\r\n        return \"confidence\";\r\n    case /* Taxonomy */6 :\r\n        return \"taxonomy\";\r\n    case /* SciName */7 :\r\n        return \"scientific_name\";\r\n    case /* ID */8 :\r\n        return \"id\";\r\n    case /* LAngle */9 :\r\n        return \"<\";\r\n    case /* LAngleSlash */10 :\r\n        return \"</\";\r\n    case /* RAngle */11 :\r\n        return \">\";\r\n    case /* Quote */12 :\r\n        return \"quote\";\r\n    case /* Eq */13 :\r\n        return \"=\";\r\n    case /* Dot */14 :\r\n        return \".\";\r\n    case /* True */15 :\r\n        return \"true\";\r\n    case /* False */16 :\r\n        return \"false\";\r\n    case /* EOF */17 :\r\n        return \"EOF\";\r\n    case /* Unit */18 :\r\n        return \"Unit\";\r\n    \r\n  }\r\n}\r\n\r\nvar word_token_map = Hashtbl.create(undefined, 16);\r\n\r\nHashtbl.add(word_token_map, \"phylogeny\", /* Phylogeny */0);\r\n\r\nHashtbl.add(word_token_map, \"name\", /* Name */1);\r\n\r\nHashtbl.add(word_token_map, \"description\", /* Description */2);\r\n\r\nHashtbl.add(word_token_map, \"clade\", /* Clade */3);\r\n\r\nHashtbl.add(word_token_map, \"rank\", /* Rank */4);\r\n\r\nHashtbl.add(word_token_map, \"confidence\", /* Confidence */5);\r\n\r\nHashtbl.add(word_token_map, \"taxonomy\", /* Taxonomy */6);\r\n\r\nHashtbl.add(word_token_map, \"scientific_name\", /* SciName */7);\r\n\r\nHashtbl.add(word_token_map, \"id\", /* ID */8);\r\n\r\nHashtbl.add(word_token_map, \"true\", /* True */15);\r\n\r\nHashtbl.add(word_token_map, \"false\", /* False */16);\r\n\r\nfunction stream_of_file(f) {\r\n  var stream = Stream.from((function (param) {\r\n          try {\r\n            return f;\r\n          }\r\n          catch (exn){\r\n            if (exn === Caml_builtin_exceptions.end_of_file) {\r\n              return ;\r\n            }\r\n            throw exn;\r\n          }\r\n        }));\r\n  var s = Stream.peek(stream);\r\n  if (s === undefined) {\r\n    return stream;\r\n  }\r\n  var val;\r\n  try {\r\n    val = $$String.sub(s, 0, 5);\r\n  }\r\n  catch (raw_exn){\r\n    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);\r\n    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {\r\n      return stream;\r\n    }\r\n    throw exn;\r\n  }\r\n  if (val !== \"<?xml\") {\r\n    return stream;\r\n  }\r\n  Stream.junk(stream);\r\n  return stream;\r\n}\r\n\r\nfunction stream_of_line(stream) {\r\n  var str;\r\n  try {\r\n    str = Stream.next(stream);\r\n  }\r\n  catch (exn){\r\n    if (exn === Stream.Failure) {\r\n      throw Caml_builtin_exceptions.end_of_file;\r\n    }\r\n    throw exn;\r\n  }\r\n  return Stream.of_string(str);\r\n}\r\n\r\nfunction is_special_char(c) {\r\n  if (c >= 60) {\r\n    return c < 63;\r\n  } else {\r\n    return c === 34;\r\n  }\r\n}\r\n\r\nfunction lex_keyword(stream, acc) {\r\n  var c = Stream.peek(stream);\r\n  if (c !== undefined) {\r\n    var val;\r\n    try {\r\n      val = c;\r\n    }\r\n    catch (exn){\r\n      if (exn === Stream.Failure) {\r\n        return lex_keyword_helper(acc);\r\n      }\r\n      throw exn;\r\n    }\r\n    if (val !== 32) {\r\n      if (Hashtbl.mem(word_token_map, acc)) {\r\n        return Hashtbl.find(word_token_map, acc);\r\n      } else if (is_special_char(c)) {\r\n        return /* Word */Block.__(1, [acc]);\r\n      } else {\r\n        Stream.junk(stream);\r\n        return lex_keyword(stream, acc + Char.escaped(c));\r\n      }\r\n    } else {\r\n      return lex_keyword_helper(acc);\r\n    }\r\n  } else {\r\n    return lex_keyword_helper(acc);\r\n  }\r\n}\r\n\r\nfunction lex_keyword_helper(acc) {\r\n  if (Hashtbl.mem(word_token_map, acc)) {\r\n    return Hashtbl.find(word_token_map, acc);\r\n  } else {\r\n    return /* Word */Block.__(1, [acc]);\r\n  }\r\n}\r\n\r\nfunction is_number(c) {\r\n  return !(c > 57 || c < 48);\r\n}\r\n\r\nfunction lex_number(stream, _acc) {\r\n  while(true) {\r\n    var acc = _acc;\r\n    var c = Stream.peek(stream);\r\n    if (c === undefined) {\r\n      return /* Num */Block.__(0, [Caml_format.caml_int_of_string(acc)]);\r\n    }\r\n    if (!is_number(c)) {\r\n      return /* Num */Block.__(0, [Caml_format.caml_int_of_string(acc)]);\r\n    }\r\n    Stream.junk(stream);\r\n    _acc = acc + Char.escaped(c);\r\n    continue ;\r\n  };\r\n}\r\n\r\nfunction tokenize_next_line(stream) {\r\n  var x;\r\n  try {\r\n    x = stream_of_line(stream);\r\n  }\r\n  catch (exn){\r\n    if (exn === Caml_builtin_exceptions.end_of_file) {\r\n      return /* :: */[\r\n              /* EOF */17,\r\n              /* [] */0\r\n            ];\r\n    }\r\n    throw exn;\r\n  }\r\n  var _acc = /* [] */0;\r\n  while(true) {\r\n    var acc = _acc;\r\n    var exit = 0;\r\n    var c;\r\n    try {\r\n      c = Stream.next(x);\r\n      exit = 1;\r\n    }\r\n    catch (exn$1){\r\n      if (exn$1 === Stream.Failure) {\r\n        return List.rev(acc);\r\n      }\r\n      if (exn$1 === Caml_builtin_exceptions.end_of_file) {\r\n        return /* :: */[\r\n                /* EOF */17,\r\n                /* [] */0\r\n              ];\r\n      }\r\n      throw exn$1;\r\n    }\r\n    if (exit === 1) {\r\n      var exit$1 = 0;\r\n      if (c >= 32) {\r\n        if (c !== 46) {\r\n          if (c >= 60) {\r\n            if (c >= 63) {\r\n              exit$1 = 2;\r\n            } else {\r\n              switch (c - 60 | 0) {\r\n                case 0 :\r\n                    var n = Stream.peek(x);\r\n                    if (n === undefined) {\r\n                      return List.rev(/* :: */[\r\n                                  /* LAngle */9,\r\n                                  acc\r\n                                ]);\r\n                    }\r\n                    if (n === /* \"/\" */47) {\r\n                      Stream.junk(x);\r\n                      _acc = /* :: */[\r\n                        /* LAngleSlash */10,\r\n                        acc\r\n                      ];\r\n                      continue ;\r\n                    }\r\n                    _acc = /* :: */[\r\n                      /* LAngle */9,\r\n                      acc\r\n                    ];\r\n                    continue ;\r\n                case 1 :\r\n                    _acc = /* :: */[\r\n                      /* Eq */13,\r\n                      acc\r\n                    ];\r\n                    continue ;\r\n                case 2 :\r\n                    _acc = /* :: */[\r\n                      /* RAngle */11,\r\n                      acc\r\n                    ];\r\n                    continue ;\r\n                \r\n              }\r\n            }\r\n          } else if (c >= 35) {\r\n            exit$1 = 2;\r\n          } else {\r\n            switch (c - 32 | 0) {\r\n              case 0 :\r\n                  continue ;\r\n              case 1 :\r\n                  exit$1 = 2;\r\n                  break;\r\n              case 2 :\r\n                  _acc = /* :: */[\r\n                    /* Quote */12,\r\n                    acc\r\n                  ];\r\n                  continue ;\r\n              \r\n            }\r\n          }\r\n        } else {\r\n          _acc = /* :: */[\r\n            /* Dot */14,\r\n            acc\r\n          ];\r\n          continue ;\r\n        }\r\n      } else if (c >= 11) {\r\n        if (c !== 13) {\r\n          exit$1 = 2;\r\n        } else {\r\n          continue ;\r\n        }\r\n      } else {\r\n        if (c >= 9) {\r\n          continue ;\r\n        }\r\n        exit$1 = 2;\r\n      }\r\n      if (exit$1 === 2) {\r\n        if (is_number(c)) {\r\n          _acc = /* :: */[\r\n            lex_number(x, Char.escaped(c)),\r\n            acc\r\n          ];\r\n          continue ;\r\n        }\r\n        _acc = /* :: */[\r\n          lex_keyword(x, Char.escaped(c)),\r\n          acc\r\n        ];\r\n        continue ;\r\n      }\r\n      \r\n    }\r\n    \r\n  };\r\n}\r\n\r\nfunction token_function_builder(stream) {\r\n  var tokens_in_line = {\r\n    contents: tokenize_next_line(stream)\r\n  };\r\n  var token_function = {\r\n    contents: (function (b, param) {\r\n        return /* EOF */17;\r\n      })\r\n  };\r\n  token_function.contents = (function (b) {\r\n      if (b) {\r\n        return (function (param) {\r\n            var match = tokens_in_line.contents;\r\n            if (match) {\r\n              return match[0];\r\n            } else {\r\n              tokens_in_line.contents = tokenize_next_line(stream);\r\n              return Curry._2(token_function.contents, true, undefined);\r\n            }\r\n          });\r\n      } else {\r\n        return (function (param) {\r\n            var match = tokens_in_line.contents;\r\n            if (match) {\r\n              tokens_in_line.contents = match[1];\r\n              return /* Unit */18;\r\n            } else {\r\n              tokens_in_line.contents = tokenize_next_line(stream);\r\n              return /* Unit */18;\r\n            }\r\n          });\r\n      }\r\n    });\r\n  return token_function.contents;\r\n}\r\n\r\nexport {\r\n  is_word ,\r\n  to_string ,\r\n  stream_of_file ,\r\n  tokenize_next_line ,\r\n  token_function_builder ,\r\n  \r\n}\r\n/* word_token_map Not a pure module */\r\n","// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE\r\n\r\nimport * as Block from \"bs-platform/lib/es6/block.js\";\r\nimport * as Curry from \"bs-platform/lib/es6/curry.js\";\r\nimport * as Caml_obj from \"bs-platform/lib/es6/caml_obj.js\";\r\nimport * as Caml_format from \"bs-platform/lib/es6/caml_format.js\";\r\nimport * as Caml_exceptions from \"bs-platform/lib/es6/caml_exceptions.js\";\r\nimport * as Tree$PhyloLibWeb from \"./tree.bs.js\";\r\nimport * as Lexer$PhyloLibWeb from \"./lexer.bs.js\";\r\n\r\nvar $$SyntaxError = Caml_exceptions.create(\"Phylo_parser-PhyloLibWeb.SyntaxError\");\r\n\r\nvar empty_phylo = {\r\n  name: \"\",\r\n  description: \"\",\r\n  tree: Tree$PhyloLibWeb.empty\r\n};\r\n\r\nvar empty_clade_attr = {\r\n  name: undefined,\r\n  rank: undefined,\r\n  confidence: undefined,\r\n  taxonomy: undefined\r\n};\r\n\r\nfunction empty_start_tag(t) {\r\n  return {\r\n          tag_name: t,\r\n          str_attr: undefined,\r\n          num_attr: undefined,\r\n          bool_attr: undefined\r\n        };\r\n}\r\n\r\nfunction print_debug(s) {\r\n  \r\n}\r\n\r\nvar peek = {\r\n  contents: (function (param) {\r\n      return /* EOF */17;\r\n    })\r\n};\r\n\r\nvar consume_token = {\r\n  contents: (function (param) {\r\n      return /* EOF */17;\r\n    })\r\n};\r\n\r\nfunction consume(token) {\r\n  var x = Curry._1(peek.contents, undefined);\r\n  if (Caml_obj.caml_equal(x, token)) {\r\n    Curry._1(consume_token.contents, undefined);\r\n    return ;\r\n  }\r\n  print_debug(\"Expected \" + (Lexer$PhyloLibWeb.to_string(token) + (\", got \" + Lexer$PhyloLibWeb.to_string(x))));\r\n  throw $$SyntaxError;\r\n}\r\n\r\nfunction is_valid_tag(t) {\r\n  if (typeof t !== \"number\") {\r\n    if (t.tag === /* Word */1) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n  switch (t) {\r\n    case /* Phylogeny */0 :\r\n    case /* Name */1 :\r\n    case /* Description */2 :\r\n    case /* Clade */3 :\r\n    case /* Rank */4 :\r\n    case /* Confidence */5 :\r\n    case /* Taxonomy */6 :\r\n    case /* SciName */7 :\r\n    case /* ID */8 :\r\n        return true;\r\n    default:\r\n      return false;\r\n  }\r\n}\r\n\r\nfunction parse_words(_acc) {\r\n  while(true) {\r\n    var acc = _acc;\r\n    var w = Curry._1(peek.contents, undefined);\r\n    if (typeof w === \"number\") {\r\n      switch (w) {\r\n        case /* Name */1 :\r\n        case /* Description */2 :\r\n        case /* Clade */3 :\r\n        case /* Rank */4 :\r\n        case /* Confidence */5 :\r\n        case /* Taxonomy */6 :\r\n        case /* ID */8 :\r\n        case /* Dot */14 :\r\n        case /* True */15 :\r\n            break;\r\n        default:\r\n          return acc;\r\n      }\r\n    } else {\r\n      if (w.tag) {\r\n        var s = w[0];\r\n        consume(/* Word */Block.__(1, [s]));\r\n        if (acc !== \"\") {\r\n          _acc = acc + (\" \" + s);\r\n          continue ;\r\n        }\r\n        _acc = s;\r\n        continue ;\r\n      }\r\n      var n = w[0];\r\n      consume(/* Num */Block.__(0, [n]));\r\n      if (acc !== \"\") {\r\n        _acc = acc + (\" \" + String(n));\r\n        continue ;\r\n      }\r\n      _acc = String(n);\r\n      continue ;\r\n    }\r\n    consume(w);\r\n    if (acc !== \"\") {\r\n      _acc = acc + (\" \" + Lexer$PhyloLibWeb.to_string(w));\r\n      continue ;\r\n    }\r\n    _acc = Lexer$PhyloLibWeb.to_string(w);\r\n    continue ;\r\n  };\r\n}\r\n\r\nfunction add_assoc(lst, attr) {\r\n  if (lst !== undefined) {\r\n    return /* :: */[\r\n            attr,\r\n            lst\r\n          ];\r\n  } else {\r\n    return /* :: */[\r\n            attr,\r\n            /* [] */0\r\n          ];\r\n  }\r\n}\r\n\r\nfunction consume_end_tag(t) {\r\n  consume(/* LAngleSlash */10);\r\n  consume(t);\r\n  return consume(/* RAngle */11);\r\n}\r\n\r\nfunction add_attr(tag, attr) {\r\n  var x = Curry._1(peek.contents, undefined);\r\n  if (typeof x === \"number\") {\r\n    if (x === /* Quote */12) {\r\n      consume(/* Quote */12);\r\n      var match = Curry._1(peek.contents, undefined);\r\n      var return_tag;\r\n      if (typeof match === \"number\") {\r\n        if (match !== 15) {\r\n          if (match !== 16) {\r\n            print_debug(\"add_attr\\n       attribute error\");\r\n            throw $$SyntaxError;\r\n          }\r\n          consume(/* False */16);\r\n          return_tag = {\r\n            tag_name: tag.tag_name,\r\n            str_attr: tag.str_attr,\r\n            num_attr: tag.num_attr,\r\n            bool_attr: add_assoc(tag.bool_attr, /* tuple */[\r\n                  attr,\r\n                  false\r\n                ])\r\n          };\r\n        } else {\r\n          consume(/* True */15);\r\n          return_tag = {\r\n            tag_name: tag.tag_name,\r\n            str_attr: tag.str_attr,\r\n            num_attr: tag.num_attr,\r\n            bool_attr: add_assoc(tag.bool_attr, /* tuple */[\r\n                  attr,\r\n                  true\r\n                ])\r\n          };\r\n        }\r\n      } else {\r\n        var words = parse_words(\"\");\r\n        return_tag = {\r\n          tag_name: tag.tag_name,\r\n          str_attr: add_assoc(tag.str_attr, /* tuple */[\r\n                attr,\r\n                words\r\n              ]),\r\n          num_attr: tag.num_attr,\r\n          bool_attr: tag.bool_attr\r\n        };\r\n      }\r\n      consume(/* Quote */12);\r\n      return return_tag;\r\n    }\r\n    print_debug(\"add_attr\\n match failure\");\r\n    throw $$SyntaxError;\r\n  } else {\r\n    if (x.tag) {\r\n      print_debug(\"add_attr\\n match failure\");\r\n      throw $$SyntaxError;\r\n    }\r\n    var x$1 = x[0];\r\n    consume(/* Num */Block.__(0, [x$1]));\r\n    return {\r\n            tag_name: tag.tag_name,\r\n            str_attr: tag.str_attr,\r\n            num_attr: add_assoc(tag.num_attr, /* tuple */[\r\n                  attr,\r\n                  x$1\r\n                ]),\r\n            bool_attr: tag.bool_attr\r\n          };\r\n  }\r\n}\r\n\r\nfunction parse_start_tag(param) {\r\n  consume(/* LAngle */9);\r\n  var x = Curry._1(peek.contents, undefined);\r\n  var tmp;\r\n  if (is_valid_tag(x)) {\r\n    consume(x);\r\n    tmp = empty_start_tag(x);\r\n  } else {\r\n    print_debug(\"parse_start_tag error\");\r\n    throw $$SyntaxError;\r\n  }\r\n  var _tag = tmp;\r\n  while(true) {\r\n    var tag = _tag;\r\n    var x$1 = Curry._1(peek.contents, undefined);\r\n    if (Lexer$PhyloLibWeb.is_word(x$1)) {\r\n      consume(x$1);\r\n      consume(/* Eq */13);\r\n      var attr = Lexer$PhyloLibWeb.to_string(x$1);\r\n      _tag = add_attr(tag, attr);\r\n      continue ;\r\n    }\r\n    if (typeof x$1 === \"number\") {\r\n      if (x$1 !== 11) {\r\n        print_debug(\"parse_attr match failure\");\r\n        throw $$SyntaxError;\r\n      }\r\n      consume(/* RAngle */11);\r\n      return tag;\r\n    }\r\n    print_debug(\"parse_attr match failure\");\r\n    throw $$SyntaxError;\r\n  };\r\n}\r\n\r\nfunction ignore_tag(t) {\r\n  while(true) {\r\n    var x = Curry._1(peek.contents, undefined);\r\n    if (typeof x === \"number\") {\r\n      if (x !== 9) {\r\n        if (x === 10) {\r\n          return consume_end_tag(t);\r\n        }\r\n        consume(x);\r\n        continue ;\r\n      }\r\n      var tag = parse_start_tag(undefined);\r\n      ignore_tag(tag.tag_name);\r\n      continue ;\r\n    }\r\n    consume(x);\r\n    continue ;\r\n  };\r\n}\r\n\r\nfunction parse_name(param) {\r\n  var match = Curry._1(peek.contents, undefined);\r\n  if (typeof match === \"number\") {\r\n    print_debug(\"Name not word/number\");\r\n    throw $$SyntaxError;\r\n  }\r\n  var name = parse_words(\"\");\r\n  consume_end_tag(/* Name */1);\r\n  return name;\r\n}\r\n\r\nfunction parse_description(param) {\r\n  var match = Curry._1(peek.contents, undefined);\r\n  if (typeof match === \"number\") {\r\n    print_debug(\"Description not word/number\");\r\n    throw $$SyntaxError;\r\n  }\r\n  var descr = parse_words(\"\");\r\n  consume_end_tag(/* Description */2);\r\n  return descr;\r\n}\r\n\r\nfunction parse_float(n) {\r\n  consume(/* Dot */14);\r\n  var x = Curry._1(peek.contents, undefined);\r\n  if (typeof x === \"number\") {\r\n    print_debug(\"Warning: confidence not valid. Set to default 0.0\");\r\n    consume_end_tag(/* Confidence */5);\r\n    return 0.0;\r\n  }\r\n  if (x.tag) {\r\n    print_debug(\"Warning: confidence not valid. Set to default 0.0\");\r\n    consume_end_tag(/* Confidence */5);\r\n    return 0.0;\r\n  }\r\n  var x$1 = x[0];\r\n  var f = Caml_format.caml_float_of_string(String(n) + (\".\" + String(x$1)));\r\n  consume(/* Num */Block.__(0, [x$1]));\r\n  consume_end_tag(/* Confidence */5);\r\n  return f;\r\n}\r\n\r\nfunction parse_confidence(param) {\r\n  var n = Curry._1(peek.contents, undefined);\r\n  if (typeof n === \"number\") {\r\n    if (n === /* Dot */14) {\r\n      return parse_float(0);\r\n    }\r\n    print_debug(\"Confidence not a number\");\r\n    throw $$SyntaxError;\r\n  } else {\r\n    if (n.tag) {\r\n      print_debug(\"Confidence not a number\");\r\n      throw $$SyntaxError;\r\n    }\r\n    var n$1 = n[0];\r\n    consume(/* Num */Block.__(0, [n$1]));\r\n    if (Curry._1(peek.contents, undefined) === /* Dot */14) {\r\n      return parse_float(n$1);\r\n    } else {\r\n      consume_end_tag(/* Confidence */5);\r\n      return n$1;\r\n    }\r\n  }\r\n}\r\n\r\nfunction parse_id(param) {\r\n  var match = Curry._1(peek.contents, undefined);\r\n  if (typeof match === \"number\") {\r\n    print_debug(\"ID not word/number\");\r\n    throw $$SyntaxError;\r\n  }\r\n  var name = parse_words(\"\");\r\n  consume_end_tag(/* ID */8);\r\n  return name;\r\n}\r\n\r\nfunction parse_scientific_name(param) {\r\n  var match = Curry._1(peek.contents, undefined);\r\n  if (typeof match === \"number\") {\r\n    print_debug(\"Scientific name not word/number\");\r\n    throw $$SyntaxError;\r\n  }\r\n  var name = parse_words(\"\");\r\n  consume_end_tag(/* SciName */7);\r\n  return name;\r\n}\r\n\r\nfunction parse_taxonomy(_taxonomy) {\r\n  while(true) {\r\n    var taxonomy = _taxonomy;\r\n    var match = Curry._1(peek.contents, undefined);\r\n    if (typeof match === \"number\") {\r\n      if (match !== 9) {\r\n        if (match !== 10) {\r\n          print_debug(\"Unexpected token encountered when parsing taxonomy\");\r\n          throw $$SyntaxError;\r\n        }\r\n        consume_end_tag(/* Taxonomy */6);\r\n        return taxonomy;\r\n      }\r\n      var tag = parse_start_tag(undefined);\r\n      var x = tag.tag_name;\r\n      if (typeof x === \"number\") {\r\n        if (x !== 7) {\r\n          if (x !== 8) {\r\n            ignore_tag(x);\r\n            continue ;\r\n          }\r\n          _taxonomy = {\r\n            id: parse_id(undefined),\r\n            scientific_name: taxonomy.scientific_name\r\n          };\r\n          continue ;\r\n        }\r\n        _taxonomy = {\r\n          id: taxonomy.id,\r\n          scientific_name: parse_scientific_name(undefined)\r\n        };\r\n        continue ;\r\n      }\r\n      ignore_tag(x);\r\n      continue ;\r\n    }\r\n    print_debug(\"Unexpected token encountered when parsing taxonomy\");\r\n    throw $$SyntaxError;\r\n  };\r\n}\r\n\r\nfunction parse_clade(acc, attr) {\r\n  var match = Curry._1(peek.contents, undefined);\r\n  if (typeof match === \"number\") {\r\n    if (match !== 9) {\r\n      if (match !== 10) {\r\n        print_debug(\"parse_clade match failure\");\r\n        throw $$SyntaxError;\r\n      }\r\n      consume_end_tag(/* Clade */3);\r\n      if (Tree$PhyloLibWeb.is_empty(acc)) {\r\n        var taxon = attr.taxonomy;\r\n        if (taxon !== undefined) {\r\n          return Tree$PhyloLibWeb.leaf(taxon.scientific_name, taxon.id, attr.name);\r\n        }\r\n        var n = attr.name;\r\n        if (n !== undefined) {\r\n          return Tree$PhyloLibWeb.leaf(n, undefined, n);\r\n        } else {\r\n          print_debug(\"Warning: no name provided\");\r\n          return Tree$PhyloLibWeb.leaf_no_params(\"Unnamed\");\r\n        }\r\n      } else {\r\n        if (acc.tag) {\r\n          return acc;\r\n        }\r\n        var taxon$1 = attr.taxonomy;\r\n        var id = taxon$1 !== undefined ? taxon$1.id : undefined;\r\n        return /* Clade */Block.__(0, [\r\n                  /* clade_id */acc[/* clade_id */0],\r\n                  /* children */acc[/* children */1],\r\n                  /* bootstrap */attr.confidence,\r\n                  /* rank */attr.rank,\r\n                  /* id */id,\r\n                  /* name */attr.name\r\n                ]);\r\n      }\r\n    }\r\n    var tag = parse_start_tag(undefined);\r\n    var x = tag.tag_name;\r\n    if (typeof x === \"number\") {\r\n      switch (x) {\r\n        case /* Name */1 :\r\n            return parse_clade(acc, {\r\n                        name: parse_name(undefined),\r\n                        rank: attr.rank,\r\n                        confidence: attr.confidence,\r\n                        taxonomy: attr.taxonomy\r\n                      });\r\n        case /* Clade */3 :\r\n            if (Tree$PhyloLibWeb.is_empty(acc)) {\r\n              return parse_clade(parse_clade(acc, empty_clade_attr), attr);\r\n            }\r\n            var clade = parse_clade(Tree$PhyloLibWeb.empty, empty_clade_attr);\r\n            return parse_clade(Tree$PhyloLibWeb.zip_no_params(/* :: */[\r\n                            acc,\r\n                            /* :: */[\r\n                              clade,\r\n                              /* [] */0\r\n                            ]\r\n                          ]), attr);\r\n        case /* Confidence */5 :\r\n            return parse_clade(acc, {\r\n                        name: attr.name,\r\n                        rank: attr.rank,\r\n                        confidence: parse_confidence(undefined),\r\n                        taxonomy: attr.taxonomy\r\n                      });\r\n        case /* Taxonomy */6 :\r\n            return parse_clade(acc, {\r\n                        name: attr.name,\r\n                        rank: attr.rank,\r\n                        confidence: attr.confidence,\r\n                        taxonomy: parse_taxonomy({\r\n                              id: undefined,\r\n                              scientific_name: \"Unnamed\"\r\n                            })\r\n                      });\r\n        case /* Phylogeny */0 :\r\n        case /* Description */2 :\r\n        case /* Rank */4 :\r\n        case /* SciName */7 :\r\n        case /* ID */8 :\r\n        case /* LAngle */9 :\r\n        case /* LAngleSlash */10 :\r\n        case /* RAngle */11 :\r\n        case /* Quote */12 :\r\n        case /* Eq */13 :\r\n        case /* Dot */14 :\r\n        case /* True */15 :\r\n        case /* False */16 :\r\n        case /* EOF */17 :\r\n        case /* Unit */18 :\r\n            break;\r\n        \r\n      }\r\n    }\r\n    ignore_tag(x);\r\n    return parse_clade(acc, attr);\r\n  }\r\n  print_debug(\"parse_clade match failure\");\r\n  throw $$SyntaxError;\r\n}\r\n\r\nfunction parse_phylogeny(_acc) {\r\n  while(true) {\r\n    var acc = _acc;\r\n    var match = Curry._1(peek.contents, undefined);\r\n    if (typeof match === \"number\") {\r\n      if (match !== 9) {\r\n        if (match !== 10) {\r\n          print_debug(\"parse_phylogeny match failure\");\r\n          throw $$SyntaxError;\r\n        }\r\n        consume_end_tag(/* Phylogeny */0);\r\n        return acc;\r\n      }\r\n      var tag = parse_start_tag(undefined);\r\n      var x = tag.tag_name;\r\n      if (typeof x === \"number\") {\r\n        if (x >= 4) {\r\n          ignore_tag(x);\r\n          continue ;\r\n        }\r\n        switch (x) {\r\n          case /* Phylogeny */0 :\r\n              ignore_tag(x);\r\n              continue ;\r\n          case /* Name */1 :\r\n              _acc = {\r\n                name: parse_name(undefined),\r\n                description: acc.description,\r\n                tree: acc.tree\r\n              };\r\n              continue ;\r\n          case /* Description */2 :\r\n              _acc = {\r\n                name: acc.name,\r\n                description: parse_description(undefined),\r\n                tree: acc.tree\r\n              };\r\n              continue ;\r\n          case /* Clade */3 :\r\n              _acc = {\r\n                name: acc.name,\r\n                description: acc.description,\r\n                tree: parse_clade(acc.tree, empty_clade_attr)\r\n              };\r\n              continue ;\r\n          \r\n        }\r\n      } else {\r\n        ignore_tag(x);\r\n        continue ;\r\n      }\r\n    } else {\r\n      print_debug(\"parse_phylogeny match failure\");\r\n      throw $$SyntaxError;\r\n    }\r\n  };\r\n}\r\n\r\nfunction from_phylo(f) {\r\n  var f$1 = Lexer$PhyloLibWeb.stream_of_file(f);\r\n  var tokenizer = Lexer$PhyloLibWeb.token_function_builder(f$1);\r\n  peek.contents = Curry._1(tokenizer, true);\r\n  consume_token.contents = Curry._1(tokenizer, false);\r\n  var match = Curry._1(peek.contents, undefined);\r\n  if (typeof match === \"number\") {\r\n    if (match === 9) {\r\n      var tag = parse_start_tag(undefined);\r\n      var s = tag.tag_name;\r\n      if (typeof s === \"number\") {\r\n        print_debug(\"parse_phylo_tag error 2\");\r\n        throw $$SyntaxError;\r\n      }\r\n      if (s.tag === /* Word */1) {\r\n        if (s[0] === \"phyloxml\") {\r\n          var tag$1 = parse_start_tag(undefined);\r\n          var match$1 = tag$1.tag_name;\r\n          if (typeof match$1 === \"number\") {\r\n            if (match$1 !== 0) {\r\n              print_debug(\"parse_phylo_tag error 1\");\r\n              throw $$SyntaxError;\r\n            }\r\n            var phylo = parse_phylogeny(empty_phylo);\r\n            consume_end_tag(/* Word */Block.__(1, [\"phyloxml\"]));\r\n            return phylo;\r\n          }\r\n          print_debug(\"parse_phylo_tag error 1\");\r\n          throw $$SyntaxError;\r\n        }\r\n        print_debug(\"parse_phylo_tag error 2\");\r\n        throw $$SyntaxError;\r\n      }\r\n      print_debug(\"parse_phylo_tag error 2\");\r\n      throw $$SyntaxError;\r\n    }\r\n    if (match === 17) {\r\n      return empty_phylo;\r\n    }\r\n    print_debug(\"from_phylo_helper error\");\r\n    throw $$SyntaxError;\r\n  }\r\n  print_debug(\"from_phylo_helper error\");\r\n  throw $$SyntaxError;\r\n}\r\n\r\nexport {\r\n  $$SyntaxError ,\r\n  from_phylo ,\r\n  \r\n}\r\n/* Tree-PhyloLibWeb Not a pure module */\r\n","import React from 'react';\r\nimport { Button, Layout, Row, Upload } from 'antd';\r\nimport { UploadOutlined } from '@ant-design/icons';\r\nimport '../App.css';\r\nimport * as Tree from '../ocaml_src/tree.bs';\r\nimport * as PhyloParser from '../ocaml_src/phylo_parser.bs';\r\nconst { Content } = Layout;\r\n\r\nconst reader = new FileReader();\r\n\r\nconst printFile = async (file) => {\r\n  try {\r\n    reader.onload = () => {\r\n      const phylo = PhyloParser.from_phylo(reader.result);\r\n      console.log(Tree.to_string(phylo.tree));\r\n    };\r\n    reader.readAsText(file);\r\n  } catch (e) {\r\n    console.log(e);\r\n    console.log('File printing failed');\r\n  }\r\n};\r\n\r\nconst uploadProps = {\r\n  accept: '.xml',\r\n  action: 'https://www.mocky.io/v2/5cc8019d300000980a055e76',\r\n  headers: {\r\n    authorization: 'authorization-text',\r\n  },\r\n  transformFile(file) {\r\n    printFile(file);\r\n  },\r\n};\r\n\r\nexport default function VisualizePhyloContent() {\r\n  const heading = 'Visualize PhyloXML';\r\n  return (\r\n    <div class=\"wrapper\">\r\n      <Content justify=\"center\">\r\n        <Row className=\"page\" justify=\"center\" gutter={[16, 16]}>\r\n          <div>\r\n            <h1>{heading}</h1>\r\n            <h2>Visualize an existing phylogenetic tree. Begin by uploading a PhyloXML file, or use our example files.</h2>\r\n          </div>\r\n        </Row>\r\n        <Row className=\"upload\">\r\n          <Upload {...uploadProps}>\r\n            <Button>\r\n              <UploadOutlined />\r\n            Upload PhyloXML Files Here\r\n          </Button>\r\n          </Upload>\r\n        </Row>\r\n      </Content>\r\n    </div>\r\n  );\r\n}\r\n","import React, { useState } from 'react';\r\nimport './App.css';\r\nimport { Popover } from 'antd';\r\nimport { ArrowLeftOutlined, InfoCircleOutlined } from '@ant-design/icons';\r\nimport Context from './components/Context';\r\nimport HomeContent from './components/HomeContent';\r\nimport GeneratePhyloContent from './components/GeneratePhyloContent';\r\nimport VisualizePhyloContent from './components/VisualizePhyloContent';\r\n\r\nconst Header = ({ useBack }) => {\r\n  const { goHome } = React.useContext(Context);\r\n  const content = (\r\n    <div>\r\n      <p>Content</p>\r\n      <p>Content</p>\r\n    </div>\r\n  );\r\n  return (\r\n    <header className=\"site-header\">\r\n      <button className=\"site-title\" onClick={goHome}>\r\n        {useBack ? (\r\n          <ArrowLeftOutlined\r\n            style={{ alignSelf: 'center', paddingRight: '10px' }}\r\n          />\r\n        ) : null}\r\n        Phylo\r\n      </button>\r\n      <Popover content={content} className=\"tooltip\" title=\"Title\" trigger=\"click\">\r\n        <a class=\"tooltip\"> <InfoCircleOutlined style={{ paddingRight: '0.5em' }} />Confused by all the terms?</a>\r\n      </Popover>\r\n\r\n    </header>\r\n  );\r\n};\r\n\r\nconst App = () => {\r\n  const [screen, setScreen] = useState('HOME');\r\n\r\n  const context = React.useMemo(\r\n    () => ({\r\n      goHome: () => {\r\n        setScreen('HOME');\r\n      },\r\n      goVisualizePhylo: () => {\r\n        setScreen('VISUALIZE_PHYLO');\r\n      },\r\n      goGeneratePhylo: () => {\r\n        setScreen('GENERATE_PHYLO');\r\n      },\r\n    }),\r\n    [],\r\n  );\r\n\r\n  const CurrScreen = () => {\r\n    switch (screen) {\r\n      case 'HOME':\r\n        return <HomeContent />;\r\n      case 'VISUALIZE_PHYLO':\r\n        return <VisualizePhyloContent />;\r\n      case 'GENERATE_PHYLO':\r\n        return <GeneratePhyloContent />;\r\n      default:\r\n        return null;\r\n    }\r\n  };\r\n\r\n  return (\r\n    <Context.Provider value={context}>\r\n      <Header useBack={screen !== 'HOME'} />\r\n      <CurrScreen />\r\n    </Context.Provider>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n\r\n"],"sourceRoot":""}